{"version":3,"sources":["mvc/rules/rule-definitions.js"],"names":["NEW_COLUMN","multiColumnsToString","targetColumns","colHeaders","length","targetHeaders","map","el","slice","join","removeColumns","columns","newColumns","index","indexOf","push","applyRegex","regex","target","data","replacement","groupCount","regExp","String","error","failedCount","newRow","row","source","match","exec","parseInt","concat","splice","pyreReplace","flatMap","f","xs","reduce","acc","x","RULES","add_column_basename","title","display","rule","target_column","init","component","addColumnBasenameTarget","save","apply","sources","re","rval","add_column_rownum","addColumnRownumStart","start","rownum","add_column_value","value","addColumnValue","addValue","add_column_metadata","addColumnMetadataValue","ruleValue","startsWith","identifierIndex","substring","add_column_regex","expression","addColumnRegexTarget","addColumnRegexExpression","addColumnRegexReplacement","addColumnRegexGroupCount","group_count","addColumnRegexType","add_column_concatenate","target_column_0","target_column_1","addColumnConcatenateTarget0","addColumnConcatenateTarget1","target0","target1","add_column_substr","type","substr_type","addColumnSubstrTarget","addColumnSubstrType","addColumnSubstrLength","originalValue","end","substr","remove_columns","target_columns","removeColumnTargets","targets","add_filter_regex","addFilterRegexTarget","addFilterRegexExpression","addFilterRegexInvert","invert","filterFunction","filter","add_filter_count","which","count","addFilterCountN","addFilterCountWhich","addFilterCountInvert","inverse","dataLength","matches","add_filter_empty","addFilterEmptyTarget","addFilterEmptyInvert","add_filter_matches","addFilterMatchesTarget","addFilterMatchesValue","addFilterMatchesInvert","add_filter_compare","compare_type","addFilterCompareTarget","addFilterCompareValue","addFilterCompareType","targetValue","parseFloat","sort","addSortingTarget","addSortingNumeric","numeric","sortable","_","zip","sortFunc","a","b","aVal","bVal","newData","newSources","zipped","swap_columns","swapColumnsTarget0","swapColumnsTarget1","tempColumn","split_columns","splitColumnsTargets0","splitColumnsTargets1","target_columns_0","target_columns_1","targets0","targets1","splitRow","newRow0","newRow1","src","MAPPING_TARGETS","list_identifiers","multiple","label","columnHeader","help","importType","paired_identifier","collection_name","modes","name","dbkey","file_type","url","info","ftp_path","requiresFtp","columnDisplay","columnNames","idx","colHeadersFor","i","fromCharCode","applyRules","rules","colHeadersPerRule","hasRuleError","ruleIndex","ruleHeaders","warn","ruleType","ruleDef","res"],"mappings":"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","file":"../../../scripts/mvc/rules/rule-definitions.js","sourcesContent":["import _l from \"utils/localization\";\nimport pyre from \"pyre-to-regexp\";\n\nconst NEW_COLUMN = \"new\";\n\nconst multiColumnsToString = function(targetColumns, colHeaders) {\n    if (targetColumns.length == 0) {\n        return `no columns`;\n    } else if (targetColumns.length == 1) {\n        return `column ${colHeaders[targetColumns[0]]}`;\n    } else {\n        const targetHeaders = targetColumns.map(el => colHeaders[el]);\n        // https://stackoverflow.com/questions/16251822/array-to-comma-separated-string-and-for-last-tag-use-the-and-instead-of-comma\n        return `columns ${[targetHeaders.slice(0, -1).join(\", \"), targetHeaders.slice(-1)[0]].join(\" and \")}`;\n    }\n};\n\nconst removeColumns = function(columns, targetColumns) {\n    const newColumns = [];\n    for (let index in columns) {\n        if (targetColumns.indexOf(index) === -1) {\n            newColumns.push(columns[index]);\n        }\n    }\n    return newColumns;\n};\n\nconst applyRegex = function(regex, target, data, replacement, groupCount) {\n    let regExp;\n    try {\n        regExp = pyre(String(regex));\n    } catch (error) {\n        return { error: `Invalid regular expression specified.` };\n    }\n    let failedCount = 0;\n    function newRow(row) {\n        const source = row[target];\n        const match = regExp.exec(source);\n        if (!match) {\n            failedCount++;\n            return null;\n        }\n        if (!replacement) {\n            groupCount = groupCount && parseInt(groupCount);\n            if (groupCount) {\n                if (match.length != groupCount + 1) {\n                    failedCount++;\n                    return null;\n                }\n                return row.concat(match.splice(1, match.length));\n            } else {\n                return row.concat([match[0]]);\n            }\n        } else {\n            return row.concat([regExp.pyreReplace(match[0], replacement)]);\n        }\n    }\n    data = data.map(newRow);\n    if (failedCount > 0) {\n        return { error: `${failedCount} row(s) failed to match specified regular expression.` };\n    }\n    return { data };\n};\n\nconst flatMap = (f, xs) => {\n    return xs.reduce((acc, x) => acc.concat(f(x)), []);\n};\n\nconst RULES = {\n    add_column_basename: {\n        title: _l(\"Basename of Path of URL\"),\n        display: (rule, colHeaders) => {\n            return `Add column using basename of column ${colHeaders[rule.target_column]}`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addColumnBasenameTarget = 0;\n            } else {\n                component.addColumnBasenameTarget = rule.target_column;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addColumnBasenameTarget;\n        },\n        apply: (rule, data, sources, columns) => {\n            // https://github.com/kgryte/regex-basename-posix/blob/master/lib/index.js\n            //const re = /^(?:\\/?|)(?:[\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(?:\\.[^.\\/]*|))(?:[\\/]*)$/;\n            // https://stackoverflow.com/questions/8376525/get-value-of-a-string-after-a-slash-in-javascript\n            const re = \"[^/]*$\";\n            const target = rule.target_column;\n            const rval = applyRegex(re, target, data);\n            columns.push(NEW_COLUMN);\n            rval.columns = columns;\n            return rval;\n        }\n    },\n    add_column_rownum: {\n        title: _l(\"Row Number\"),\n        display: (rule, colHeaders) => {\n            return `Add column for the current row number.`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addColumnRownumStart = 1;\n            } else {\n                component.addColumnRownumStart = rule.start;\n            }\n        },\n        save: (component, rule) => {\n            rule.start = parseInt(component.addColumnRownumStart);\n        },\n        apply: (rule, data, sources, columns) => {\n            let rownum = rule.start;\n            function newRow(row) {\n                const newRow = row.slice();\n                newRow.push(String(rownum));\n                rownum += 1;\n                return newRow;\n            }\n            data = data.map(newRow);\n            columns.push(NEW_COLUMN);\n            return { data, columns };\n        }\n    },\n    add_column_value: {\n        title: _l(\"Fixed Value\"),\n        display: (rule, colHeaders) => {\n            return `Add column for the constant value of ${rule.value}.`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addColumnValue = \"\";\n            } else {\n                component.addColumnValue = rule.value;\n            }\n        },\n        save: (component, rule) => {\n            rule.value = component.addColumnValue;\n        },\n        apply: (rule, data, sources, columns) => {\n            const addValue = rule.value;\n            function newRow(row) {\n                const newRow = row.slice();\n                newRow.push(addValue);\n                return newRow;\n            }\n            data = data.map(newRow);\n            columns.push(NEW_COLUMN);\n            return { data, columns };\n        }\n    },\n    add_column_metadata: {\n        title: _l(\"Add Column from Metadata\"),\n        display: (rule, colHeaders) => {\n            return `Add column for ${rule.value}.`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addColumnMetadataValue = null;\n            } else {\n                component.addColumnMetadataValue = rule.value;\n            }\n        },\n        save: (component, rule) => {\n            rule.value = component.addColumnMetadataValue;\n        },\n        apply: (rule, data, sources, columns) => {\n            const ruleValue = rule.value;\n            let newRow;\n            if (ruleValue.startsWith(\"identifier\")) {\n                const identifierIndex = parseInt(ruleValue.substring(\"identifier\".length));\n                newRow = (row, index) => {\n                    const newRow = row.slice();\n                    newRow.push(sources[index][\"identifiers\"][identifierIndex]);\n                    return newRow;\n                };\n            } else if (ruleValue == \"hid\" || ruleValue == \"name\" || ruleValue == \"path\") {\n                newRow = (row, index) => {\n                    const newRow = row.slice();\n                    newRow.push(sources[index][ruleValue]);\n                    return newRow;\n                };\n            } else {\n                return { error: `Unknown metadata type [${ruleValue}}]` };\n            }\n            data = data.map(newRow);\n            columns.push(NEW_COLUMN);\n            return { data, columns };\n        }\n    },\n    add_column_regex: {\n        title: _l(\"Using a Regular Expression\"),\n        display: (rule, colHeaders) => {\n            return `Add new column using ${rule.expression} applied to column ${colHeaders[rule.target_column]}`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addColumnRegexTarget = 0;\n                component.addColumnRegexExpression = \"\";\n                component.addColumnRegexReplacement = null;\n                component.addColumnRegexGroupCount = null;\n            } else {\n                component.addColumnRegexTarget = rule.target_column;\n                component.addColumnRegexExpression = rule.expression;\n                component.addColumnRegexReplacement = rule.replacement;\n                component.addColumnRegexGroupCount = rule.group_count;\n            }\n            let addColumnRegexType = \"global\";\n            if (component.addColumnRegexGroupCount) {\n                addColumnRegexType = \"groups\";\n            } else if (component.addColumnRegexReplacement) {\n                addColumnRegexType = \"replacement\";\n            }\n            component.addColumnRegexType = addColumnRegexType;\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addColumnRegexTarget;\n            rule.expression = component.addColumnRegexExpression;\n            if (component.addColumnRegexReplacement) {\n                rule.replacement = component.addColumnRegexReplacement;\n            }\n            if (component.addColumnRegexGroupCount) {\n                rule.group_count = component.addColumnRegexGroupCount;\n            }\n        },\n        apply: (rule, data, sources, columns) => {\n            const target = rule.target_column;\n            const rval = applyRegex(rule.expression, target, data, rule.replacement, rule.group_count);\n            columns.push(NEW_COLUMN);\n            rval.columns = columns;\n            return rval;\n        }\n    },\n    add_column_concatenate: {\n        title: _l(\"Concatenate Columns\"),\n        display: (rule, colHeaders) => {\n            return `Concatenate column ${colHeaders[rule.target_column_0]} and column ${\n                colHeaders[rule.target_column_1]\n            }`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addColumnConcatenateTarget0 = 0;\n                component.addColumnConcatenateTarget1 = 0;\n            } else {\n                component.addColumnConcatenateTarget0 = rule.target_column_0;\n                component.addColumnConcatenateTarget1 = rule.target_column_1;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column_0 = component.addColumnConcatenateTarget0;\n            rule.target_column_1 = component.addColumnConcatenateTarget1;\n        },\n        apply: (rule, data, sources, columns) => {\n            const target0 = rule.target_column_0;\n            const target1 = rule.target_column_1;\n            function newRow(row) {\n                const newRow = row.slice();\n                newRow.push(row[target0] + row[target1]);\n                return newRow;\n            }\n            data = data.map(newRow);\n            columns.push(NEW_COLUMN);\n            return { data, columns };\n        }\n    },\n    add_column_substr: {\n        title: _l(\"Keep or Trim Prefix or Suffix\"),\n        display: (rule, colHeaders) => {\n            const type = rule.substr_type;\n            let display;\n            if (type == \"keep_prefix\") {\n                display = `Keep only ${rule.length} characters from the start of column ${\n                    colHeaders[rule.target_column]\n                }`;\n            } else if (type == \"drop_prefix\") {\n                display = `Remove ${rule.length} characters from the start of column ${colHeaders[rule.target_column]}`;\n            } else if (type == \"keep_suffix\") {\n                display = `Keep only ${rule.length} characters from the end of column ${\n                    colHeaders[rule.target_column]\n                }`;\n            } else {\n                display = `Remove ${rule.length} characters from the end of column ${colHeaders[rule.target_column]}`;\n            }\n            return display;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addColumnSubstrTarget = 0;\n                component.addColumnSubstrType = \"keep_prefix\";\n                component.addColumnSubstrLength = 1;\n            } else {\n                component.addColumnSubstrTarget = rule.target_column;\n                component.addColumnSubstrLength = rule.length;\n                component.addColumnSubstrType = rule.substr_type;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addColumnSubstrTarget;\n            rule.length = component.addColumnSubstrLength;\n            rule.substr_type = component.addColumnSubstrType;\n        },\n        apply: (rule, data, sources, columns) => {\n            const target = rule.target_column;\n            const length = rule.length;\n            const type = rule.substr_type;\n            function newRow(row) {\n                const newRow = row.slice();\n                const originalValue = row[target];\n                let start = 0,\n                    end = originalValue.length;\n                if (type == \"keep_prefix\") {\n                    end = length;\n                } else if (type == \"drop_prefix\") {\n                    start = length;\n                } else if (type == \"keep_suffix\") {\n                    start = end - length;\n                    if (start < 0) {\n                        start = 0;\n                    }\n                } else {\n                    end = end - length;\n                    if (end < 0) {\n                        end = 0;\n                    }\n                }\n                newRow.push(originalValue.substr(start, end));\n                return newRow;\n            }\n            data = data.map(newRow);\n            columns.push(NEW_COLUMN);\n            return { data };\n        }\n    },\n    remove_columns: {\n        title: _l(\"Remove Column(s)\"),\n        display: (rule, colHeaders) => {\n            const targetColumns = rule.target_columns;\n            return `Remove ${multiColumnsToString(targetColumns, colHeaders)}`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.removeColumnTargets = [];\n            } else {\n                component.removeColumnTargets = rule.target_columns;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_columns = component.removeColumnTargets;\n        },\n        apply: (rule, data, sources, columns) => {\n            const targets = rule.target_columns;\n            function newRow(row) {\n                const newRow = [];\n                for (let index in row) {\n                    if (targets.indexOf(parseInt(index)) == -1) {\n                        newRow.push(row[index]);\n                    }\n                }\n                return newRow;\n            }\n            data = data.map(newRow);\n            columns = removeColumns(columns, targets);\n            return { data, columns };\n        }\n    },\n    add_filter_regex: {\n        title: _l(\"Using a Regular Expression\"),\n        display: (rule, colHeaders) => {\n            return `Filter rows using regular expression ${rule.expression} on column ${\n                colHeaders[rule.target_column]\n            }`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addFilterRegexTarget = 0;\n                component.addFilterRegexExpression = \"\";\n                component.addFilterRegexInvert = false;\n            } else {\n                component.addFilterRegexTarget = rule.target_column;\n                component.addFilterRegexExpression = rule.expression;\n                component.addFilterRegexInvert = rule.invert;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addFilterRegexTarget;\n            rule.expression = component.addFilterRegexExpression;\n            rule.invert = component.addFilterRegexInvert;\n        },\n        apply: (rule, data, sources, columns) => {\n            const regex = String(rule.expression);\n            var regExp;\n            try {\n                regExp = pyre(regex);\n            } catch (error) {\n                return { error: `Invalid regular expression specified.` };\n            }\n            const target = rule.target_column;\n            const invert = rule.invert;\n            const filterFunction = function(el, index) {\n                const row = data[parseInt(index)];\n                return regExp.exec(row[target]) ? !invert : invert;\n            };\n            sources = sources.filter(filterFunction);\n            data = data.filter(filterFunction);\n            return { data, sources };\n        }\n    },\n    add_filter_count: {\n        title: _l(\"First or Last N Rows\"),\n        display: (rule, colHeaders) => {\n            const which = rule.which;\n            const invert = rule.invert;\n            if (which == \"first\" && !invert) {\n                return `Filter out first ${rule.count} row(s).`;\n            } else if (which == \"first\" && invert) {\n                return `Keep only first ${rule.count} row(s).`;\n            } else if (which == \"last\" && !invert) {\n                return `Filter out last ${rule.count} row(s).`;\n            } else {\n                return `Keep only last ${rule.count} row(s).`;\n            }\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addFilterCountN = 0;\n                component.addFilterCountWhich = \"first\";\n                component.addFilterCountInvert = false;\n            } else {\n                component.addFilterCountN = rule.count;\n                component.addFilterCountWhich = rule.which;\n                component.addFilterCountInvert = rule.inverse;\n            }\n        },\n        save: (component, rule) => {\n            rule.count = component.addFilterCountN;\n            rule.which = component.addFilterCountWhich;\n            rule.invert = component.addFilterCountInvert;\n        },\n        apply: (rule, data, sources, columns) => {\n            const count = rule.count;\n            const invert = rule.invert;\n            const which = rule.which;\n            const dataLength = data.length;\n            const filterFunction = function(el, index) {\n                let matches;\n                if (which == \"first\") {\n                    matches = index >= count;\n                } else {\n                    matches = index < dataLength - count;\n                }\n                return matches ? !invert : invert;\n            };\n            sources = sources.filter(filterFunction);\n            data = data.filter(filterFunction);\n            return { data, sources };\n        }\n    },\n    add_filter_empty: {\n        title: _l(\"On Emptiness\"),\n        display: (rule, colHeaders) => {\n            return `Filter rows if no value for column ${colHeaders[rule.target_column]}`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addFilterEmptyTarget = 0;\n                component.addFilterEmptyInvert = false;\n            } else {\n                component.addFilterEmptyTarget = rule.target_column;\n                component.addFilterEmptyInvert = rule.invert;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addFilterEmptyTarget;\n            rule.invert = component.addFilterEmptyInvert;\n        },\n        apply: (rule, data, sources, columns) => {\n            const target = rule.target_column;\n            const invert = rule.invert;\n            const filterFunction = function(el, index) {\n                const row = data[parseInt(index)];\n                return row[target].length ? !invert : invert;\n            };\n            sources = sources.filter(filterFunction);\n            data = data.filter(filterFunction);\n            return { data, sources };\n        }\n    },\n    add_filter_matches: {\n        title: _l(\"Matching a Supplied Value\"),\n        display: (rule, colHeaders) => {\n            return `Filter rows with value ${rule.value} for column ${colHeaders[rule.target_column]}`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addFilterMatchesTarget = 0;\n                component.addFilterMatchesValue = \"\";\n                component.addFilterMatchesInvert = false;\n            } else {\n                component.addFilterMatchesTarget = rule.target_column;\n                component.addFilterMatchesValue = rule.value;\n                component.addFilterMatchesInvert = rule.invert;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addFilterMatchesTarget;\n            rule.value = component.addFilterMatchesValue;\n            rule.invert = component.addFilterMatchesInvert;\n        },\n        apply: (rule, data, sources, columns) => {\n            const target = rule.target_column;\n            const invert = rule.invert;\n            const value = rule.value;\n            const filterFunction = function(el, index) {\n                const row = data[parseInt(index)];\n                return row[target] == value ? !invert : invert;\n            };\n            sources = sources.filter(filterFunction);\n            data = data.filter(filterFunction);\n            return { data, sources };\n        }\n    },\n    add_filter_compare: {\n        title: _l(\"By Comparing to a Numeric Value\"),\n        display: (rule, colHeaders) => {\n            return `Filter rows with value ${rule.compare_type} ${rule.value} for column ${\n                colHeaders[rule.target_column]\n            }`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addFilterCompareTarget = 0;\n                component.addFilterCompareValue = 0;\n                component.addFilterCompareType = \"less_than\";\n            } else {\n                component.addFilterCompareTarget = rule.target_column;\n                component.addFilterCompareValue = rule.value;\n                component.addFilterCompareType = rule.compare_type;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addFilterCompareTarget;\n            rule.value = component.addFilterCompareValue;\n            rule.compare_type = component.addFilterCompareType;\n        },\n        apply: (rule, data, sources, columns) => {\n            const target = rule.target_column;\n            const compare_type = rule.compare_type;\n            const value = rule.value;\n            const filterFunction = function(el, index) {\n                const row = data[parseInt(index)];\n                const targetValue = parseFloat(row[target]);\n                let matches;\n                if (compare_type == \"less_than\") {\n                    matches = targetValue < value;\n                } else if (compare_type == \"less_than_equal\") {\n                    matches = targetValue <= value;\n                } else if (compare_type == \"greater_than\") {\n                    matches = targetValue > value;\n                } else if (compare_type == \"greater_than_equal\") {\n                    matches = targetValue >= value;\n                }\n                return matches;\n            };\n            sources = sources.filter(filterFunction);\n            data = data.filter(filterFunction);\n            return { data, sources };\n        }\n    },\n    sort: {\n        title: _l(\"Sort\"),\n        display: (rule, colHeaders) => {\n            return `Sort on column ${colHeaders[rule.target_column]}`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.addSortingTarget = 0;\n                component.addSortingNumeric = false;\n            } else {\n                component.addSortingTarget = rule.target_column;\n                component.addSortingNumeric = rule.numeric;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column = component.addSortingTarget;\n            rule.numeric = component.addSortingNumeric;\n        },\n        apply: (rule, data, sources, columns) => {\n            const target = rule.target_column;\n            const numeric = rule.numeric;\n\n            const sortable = _.zip(data, sources);\n\n            const sortFunc = (a, b) => {\n                let aVal = a[0][target];\n                let bVal = b[0][target];\n                if (numeric) {\n                    aVal = parseFloat(aVal);\n                    bVal = parseFloat(bVal);\n                }\n                if (aVal < bVal) {\n                    return -1;\n                } else if (bVal < aVal) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            };\n\n            sortable.sort(sortFunc);\n\n            const newData = [];\n            const newSources = [];\n\n            sortable.map(zipped => {\n                newData.push(zipped[0]);\n                newSources.push(zipped[1]);\n            });\n\n            return { data: newData, sources: newSources };\n        }\n    },\n    swap_columns: {\n        title: _l(\"Swap Column(s)\"),\n        display: (rule, colHeaders) => {\n            return `Swap ${multiColumnsToString([rule.target_column_0, rule.target_column_1], colHeaders)}`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.swapColumnsTarget0 = 0;\n                component.swapColumnsTarget1 = 0;\n            } else {\n                component.swapColumnsTarget0 = rule.target_column_0;\n                component.swapColumnsTarget1 = rule.target_column_1;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_column_0 = component.swapColumnsTarget0;\n            rule.target_column_1 = component.swapColumnsTarget1;\n        },\n        apply: (rule, data, sources, columns) => {\n            const target0 = rule.target_column_0;\n            const target1 = rule.target_column_1;\n            function newRow(row) {\n                const newRow = row.slice();\n                newRow[target0] = row[target1];\n                newRow[target1] = row[target0];\n                return newRow;\n            }\n            data = data.map(newRow);\n            const tempColumn = columns[target0];\n            columns[target0] = columns[target1];\n            columns[target1] = tempColumn;\n            return { data, columns };\n        }\n    },\n    split_columns: {\n        title: _l(\"Split Column(s)\"),\n        display: (rule, colHeaders) => {\n            return `Duplicate each row and split up columns`;\n        },\n        init: (component, rule) => {\n            if (!rule) {\n                component.splitColumnsTargets0 = [];\n                component.splitColumnsTargets1 = [];\n            } else {\n                component.splitColumnsTargets0 = rule.target_columns_0;\n                component.splitColumnsTargets1 = rule.target_columns_1;\n            }\n        },\n        save: (component, rule) => {\n            rule.target_columns_0 = component.splitColumnsTargets0;\n            rule.target_columns_1 = component.splitColumnsTargets1;\n        },\n        apply: (rule, data, sources, columns) => {\n            const targets0 = rule.target_columns_0;\n            const targets1 = rule.target_columns_1;\n\n            const splitRow = function(row) {\n                const newRow0 = [],\n                    newRow1 = [];\n                for (let index in row) {\n                    index = parseInt(index);\n                    if (targets0.indexOf(index) > -1) {\n                        newRow0.push(row[index]);\n                    } else if (targets1.indexOf(index) > -1) {\n                        newRow1.push(row[index]);\n                    } else {\n                        newRow0.push(row[index]);\n                        newRow1.push(row[index]);\n                    }\n                }\n                return [newRow0, newRow1];\n            };\n            data = flatMap(splitRow, data);\n            sources = flatMap(src => [src, src], sources);\n            columns = removeColumns(columns, targets0);\n            return { data, sources, columns };\n        }\n    }\n};\n\nconst MAPPING_TARGETS = {\n    list_identifiers: {\n        multiple: true,\n        label: _l(\"List Identifier(s)\"),\n        columnHeader: _l(\"List Identifier\"),\n        help: _l(\n            \"This should be a short description of the replicate, sample name, condition, etc... that describes each level of the list structure.\"\n        ),\n        importType: \"collections\"\n    },\n    paired_identifier: {\n        label: _l(\"Paired-end Indicator\"),\n        columnHeader: _l(\"Paired Indicator\"),\n        help: _l(\n            \"This should be set to '1', 'R1', 'forward', 'f', or 'F' to indicate forward reads, and '2', 'r', 'reverse', 'R2', 'R', or 'R2' to indicate reverse reads.\"\n        ),\n        importType: \"collections\"\n    },\n    collection_name: {\n        label: _l(\"Collection Name\"),\n        help: _l(\n            \"If this is set, all rows with the same collection name will be joined into a collection and it is possible to create multiple collections at once.\"\n        ),\n        modes: [\"raw\", \"ftp\", \"datasets\", \"library_datasets\"],\n        importType: \"collections\"\n    },\n    name: {\n        label: _l(\"Name\"),\n        importType: \"datasets\"\n    },\n    dbkey: {\n        label: _l(\"Genome\"),\n        modes: [\"raw\", \"ftp\"]\n    },\n    file_type: {\n        label: _l(\"Type\"),\n        modes: [\"raw\", \"ftp\"],\n        help: _l(\"This should be the Galaxy file type corresponding to this file.\")\n    },\n    url: {\n        label: _l(\"URL\"),\n        modes: [\"raw\"],\n        help: _l(\"This should be a URL the file can be downloaded from.\")\n    },\n    info: {\n        label: _l(\"Info\"),\n        help: _l(\n            \"Unstructured text associated with the dataset that shows up in the history panel, this is optional and can be whatever you would like.\"\n        ),\n        modes: [\"raw\", \"ftp\"]\n    },\n    ftp_path: {\n        label: _l(\"FTP Path\"),\n        modes: [\"raw\", \"ftp\"],\n        help: _l(\n            \"This should be the path to the target file to include relative to your FTP directory on the Galaxy server\"\n        ),\n        requiresFtp: true\n    }\n};\n\nconst columnDisplay = function(columns, colHeaders) {\n    let columnNames;\n    if (typeof columns == \"object\") {\n        columnNames = columns.map(idx => colHeaders[idx]);\n    } else {\n        columnNames = [colHeaders[columns]];\n    }\n    if (columnNames.length == 2) {\n        return \"columns \" + columnNames[0] + \" and \" + columnNames[1];\n    } else if (columnNames.length > 2) {\n        return \"columns \" + columnNames.slice(0, -1).join(\", \") + \", and \" + columnNames[columnNames.length - 1];\n    } else {\n        return \"column \" + columnNames[0];\n    }\n};\n\nconst colHeadersFor = function(data, columns) {\n    if (data.length == 0) {\n        if (columns) {\n            return columns.map((el, i) => String.fromCharCode(65 + i));\n        } else {\n            return [];\n        }\n    } else {\n        return data[0].map((el, i) => String.fromCharCode(65 + i));\n    }\n};\n\nconst applyRules = function(data, sources, columns, rules, colHeadersPerRule) {\n    var colHeadersPerRule = colHeadersPerRule || [];\n    let hasRuleError = false;\n    for (var ruleIndex in rules) {\n        const ruleHeaders = colHeadersFor(data, columns);\n        colHeadersPerRule[ruleIndex] = ruleHeaders;\n        const rule = rules[ruleIndex];\n        rule.error = null;\n        rule.warn = null;\n        if (hasRuleError) {\n            rule.warn = _l(\"Skipped due to previous errors.\");\n            continue;\n        }\n        var ruleType = rule.type;\n        const ruleDef = RULES[ruleType];\n        const res = ruleDef.apply(rule, data, sources, columns);\n        if (res.error) {\n            hasRuleError = true;\n            rule.error = res.error;\n        } else {\n            if (res.warn) {\n                rule.warn = res.warn;\n            }\n            data = res.data || data;\n            sources = res.sources || sources;\n            columns = res.columns || columns;\n        }\n    }\n    return { data, sources, columns };\n};\n\nexport default {\n    applyRules: applyRules,\n    columnDisplay: columnDisplay,\n    colHeadersFor: colHeadersFor,\n    RULES: RULES,\n    MAPPING_TARGETS: MAPPING_TARGETS\n};\n"]}